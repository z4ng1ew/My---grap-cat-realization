#include "s21_cat.h"

struct flags {
 int b, e, E, v, n, s, t, T, d, err_f;
};


int main(int countArg, char **arrPoint) { 
  struct flags option = {0};
  int exit_status = 0;
  int number_file = get_opt(countArg, arrPoint, &option);

  if (option.err_f == 1) {
    printf("Пожалуйста, используйте следующие опции: beEvnstT\n");
    exit_status = 1;
  } else {
    while (number_file < countArg) {  
      char *path = arrPoint[number_file]; 
      cat(path, option);  
      number_file++;  
    }
  }

  return exit_status;
}

int get_opt(int countArg, char **arrPoint, struct flags *flag) {
  int c = 0;
  int option_index = 0;
  static struct option long_options[] = {{"number-nonblank", 0, 0, 'b'},
                                         {"number", 0, 0, 'n'},
                                         {"squeeze-blank", 0, 0, 's'},
                                         {0, 0, 0, 0}};
/*
option - это не зарезервированное слово, а определение структуры, используемой в библиотеке getopt. Эта структура и её поля являются частью стандартной библиотеки для работы с опциями командной строки в POSIX-системах, таких как Linux.

В заголовочном файле <getopt.h> определена структура option, которая используется для задания длинных опций (long options).
*/
  while ((c = getopt_long(countArg, arrPoint, "beEvnstT", long_options, &option_index)) != -1) {
    handle_option(c, flag); //Если c не равен -1, это значит, что была найдена опция. handle_option(c, flag) вызывает функцию для обработки найденной опции. //Цикл продолжается, пока getopt_long не вернет -1, что указывает на то, что больше опций нет.
  }
  if (flag->b) flag->n = 0; //если активирован флаг b то нельзя одновременно активировать и флаг n
  return optind;
}



void handle_option(int c, struct flags *flag) {
    if (c == 'b') {
        flag->b = 1;
    } else if (c == 'e') {
        flag->E = 1;
        flag->v = 1;
    } else if (c == 'E') {
        flag->E = 1;
    } else if (c == 'v') {
        flag->v = 1;
    } else if (c == 'n') {
        flag->n = 1;
    } else if (c == 's') {
        flag->s = 1;
    } else if (c == 't') {
        flag->T = 1;
        flag->v = 1;
    } else if (c == 'T') {
        flag->T = 1;
    } else {
        flag->err_f = 1;
    }
}


void process_file(FILE *filename, struct flags flag) { //передаём открытый файл и структуру флагов  // Эта функция принимает указатель на файл filename и структуру flag, которая содержит флаги для обработки файла.
  int ch, prev = '\n', current_line = 1, str = 0;
  while ((ch = getc(filename)) != EOF) {
    if (s(flag, &prev, &ch, &str)) continue;  //continue переходит к следующей итерации цикла while, в которой происходит считывание следующего символа из файла с помощью getc(filename).
    b(flag, &prev, &ch, &current_line); //внутри каждой функции соит конструкция if c флагом которая проверяет был ли запрошен именно этот флаг, то есть функция process_file() поочерёдно запускает все функции
    n(flag, &prev, &current_line);
    E(flag, &prev, &ch);
    T(flag, &ch);
    v(flag, &ch);
    putchar(ch);
    prev = ch;
  }
}


//Программа считывает конец файла (EOF) с помощью функции `getc()`. Когда программа достигает конца файла при чтении файла с помощью `getc()`, функция `getc()` возвращает специальное значение `EOF`. Это значение обычно представлено макросом `EOF`, который обычно равен -1. Таким образом, когда `getc()` возвращает значение `-1`, программа понимает, что достигнут конец файла, и завершает чтение. Это условие проверяется в коде с помощью выражения `while ((ch = getc(filename)) != EOF)`, где `ch` присваивается значениям, считываемым из файла, пока не будет достигнут конец файла.


/*
В параметрах функции `process_file` передаются следующие значения:

1. **`FILE *filename`**:
   - Это указатель на структуру `FILE`, представляющую файловый поток.
   - Этот параметр передает открытый файл, с которым будет работать функция. 
   - Через этот указатель функция сможет читать содержимое файла или писать в файл.

2. **`struct flags flag`**:
   - Это структура, представляющая набор флагов (опций), которые управляют поведением функции.
   - Структура `flags` содержит булевы поля, каждое из которых соответствует определенной опции программы (`-b`, `-e`, `-E`, `-v`, `-n`, `-s`, `-t`, `-T`, `-d`, `err_f`).
   - Этот параметр передает функции информацию о том, какие опции были выбраны пользователем при запуске программы. В зависимости от этих опций функция будет по-разному обрабатывать содержимое файла.

Вот пример:

- Если флаг `b` установлен, функция будет нумеровать только непустые строки.
- Если флаг `E` установлен, функция будет добавлять символ `$` в конце каждой строки.
- Если флаг `s` установлен, функция будет сжимать несколько пустых строк в одну.

Таким образом, в параметры функции `process_file` передается указатель на открытый файл и набор флагов, определяющих, как этот файл следует обрабатывать.
*/

//FILE не является зарезервированным словом в C, но оно определено в стандартной библиотеке C и используется для работы с файлами. FILE — это тип данных, который представляет файловый поток (file stream) и используется в функциях стандартной библиотеки для работы с файлами, таких как fopen, fclose, fread, fwrite, fprintf, и других.

//Определение FILE находится в заголовочном файле <stdio.h>. Это структурный тип данных, который инкапсулирует информацию о файле или потоке ввода-вывода. Пользователю не нужно знать внутреннюю структуру FILE, достаточно знать, как использовать указатели на FILE для работы с файлами.

void cat(char *path, struct flags flag) {
  // Это объявление функции cat. Она принимает два параметра: path, строку, представляющую путь к файлу, который мы хотим прочитать, и flag, структуру, содержащую флаги для обработки файла.

  FILE *filename = fopen(path, "r");
  // Эта строка открывает файл, указанный в path, в режиме чтения ("r"). Функция fopen() возвращает указатель на файловый поток типа FILE, который затем используется для операций чтения из файла.

  if (!filename) {
  // Этот блок проверяет, удалось ли открыть файл. Если файл не существует или не удалось его открыть по какой-либо другой причине, программа выводит сообщение об ошибке в стандартный поток ошибок (stderr) и завершает выполнение функции, возвращая управление вызывающей стороне.

    fprintf(stderr, "No such file or directory\n");
    
    return;
  }

  process_file(filename, flag);
  // Если файл успешно открыт, вызывается функция process_file(), передавая ей указатель на открытый файл (filename) и структуру flag.

  fclose(filename);
  //После того как process_file() завершает свою работу, файл закрывается с помощью функции fclose(), чтобы освободить ресурсы и правильно завершить операцию чтения из файла.
}





int s(struct flags flag, int *prev, int *ch, int *str) { //позволяет сжимать пустые строки, то есть не выводить подряд идущие пустые строки, а оставлять только одну.
  int f = 0; 
  if (flag.s == 1 && (*prev == '\n' && *ch == '\n')) {
    *str = *str + 1;
    if (*str > 1) {  //Если флаг s установлен в 1 и предыдущий символ (*prev) и текущий символ (*ch) являются символами новой строки (\n), значит, встречена пустая строка.
      f = 1; //Если значение переменной str больше 1, то устанавливается значение 1 в переменную f. Это означает, что были обнаружены две или более пустых строки подряд.
    }
  } else {
    *str = 0; //Если не были обнаружены две пустые строки подряд, переменная str сбрасывается в 0.
  }
  return f; //Функция возвращает значение переменной f, которое равно 1, если были обнаружены две или более пустых строки подряд, и 0 в противном случае.

} //Эта функция используется для определения, были ли обнаружены две или более пустых строк подряд, в соответствии с флагом -s. Если это так, она возвращает 1, иначе возвращает 0.




/*
Представь что ты учитель и допустим я вписал эту команду:                                            ./s21_cat -s tests/empty_lines_b_s.txt

   Содержание файла:

   1   .Строка 1
   2   .Строка 2



   3   .Строка 3
   4   .Строка 4  


Ожидаемый результат:

   1   .Строка 1
   2   .Строка 2

   3   .Строка 3
   4   .Строка 4 


 - Объясни пошагово и понятными словами что происходит здесь, описывая каждый этап подробно, что где когда и зачем? При этой команде, что происходит здесь - int s(struct flags flag, int *prev, int *ch, int *str) {
  int f = 0;
  if (flag.s == 1 && (*prev == '\n' && *ch == '\n')) {
    *str = *str + 1;
    if (*str > 1) {
      f = 1;
    }
  } else {
    *str = 0;
  }
  return f;
}


Хорошо, давай разберем каждый этап подробно:

1. **Запуск программы**: Вы запускаете вашу программу `./s21_cat` с флагом `-s` и указанием файла `tests/empty_lines_b_s.txt`.

2. **Чтение файла**: Программа начинает чтение содержимого файла `tests/empty_lines_b_s.txt`.

3. **Обработка символов**: Для каждого символа в файле, программа выполняет следующие действия:

   - Она вызывает функцию `s`, передавая в нее текущий символ (`*ch`), предыдущий символ (`*prev`) и информацию о флагах (`struct flags flag`).
   
   - Функция `s` проверяет, установлен ли флаг `-s` и являются ли предыдущий и текущий символы символами новой строки (`'\n'`). Если это так, она увеличивает счетчик пустых строк `*str`.
   
   - Если количество пустых строк больше одной, функция `s` устанавливает флаг `f` в `1`, указывая, что текущая строка также является пустой.
   
   - Если условие не выполняется (то есть либо флаг `-s` не установлен, либо текущий символ не является символом новой строки), функция `s` устанавливает счетчик пустых строк `*str` в `0` и возвращает `0`, указывая, что текущая строка не пустая.
   
4. **Вывод на экран**: Программа выводит каждый символ на экран с помощью функции `putchar(ch)`.

5. **Обновление переменных**: После каждого шага программа обновляет значение предыдущего символа (`*prev`) на текущий символ (`*ch`), чтобы в следующем цикле обработки использовать правильные предыдущие символы.

6. **Завершение программы**: Когда файл полностью прочитан, программа завершает свое выполнение.
*/












void b(struct flags flag, int *prev, int *ch, int *current_line) {
  if (flag.b == 1) {
    if (*prev == '\n' && *ch != '\n') { //Если текущий символ равен символу новой строки, это означает, что это пустая строка, и нумерация строк не требуется.
      printf("%*d\t", 6, *current_line);
      *current_line = *current_line + 1; //После того, как номер строки был выведен, значение переменной *current_line увеличивается на 1.Это гарантирует, что следующая строка будет иметь правильный номер. Этот процесс обеспечивает нумерацию строк в соответствии с флагом -b, при условии, что текущая строка не является пустой строкой.
    }
  }
} //Если все эти условия выполняются, это означает, что мы находимся внутри строки (а не в начале пустой строки), и мы можем нумеровать эту строку. Таким образом, нумерация строк происходит только для непустых строк между двумя символами новой строки.

void n(struct flags flag, int *prev, int *current_line) {
  if (flag.n == 1) {
    if (*prev == '\n') {
      printf("%*d\t", 6, *current_line); // сначала идёт 5 пробелов а потом шестым идёт цифра
      *current_line = *current_line + 1;
    }
  }
}

void E(struct flags flag, int *prev, int *ch) { //Функция E обрабатывает символы при интерпретации строк. Если установлен флаг -E, она заменяет символы \n и выводит символ $ в зависимости от положения и наличия флага -b.
  if (flag.E == 1) { //Если флаг -E установлен
    if (*prev != '\0' && *ch == '\n') { //проверка, что предыдущий символ не является концом строки 
      if (*prev == '\n' && flag.b) { //предыдущий и текущий символ  являются символом новой строки
        printf("      \t$");
      } else {
        int dollar = '$'; //Если не выполнено внутреннее условие, выводится символ $.
        putc(dollar, stdout); //Это происходит, когда строка не начинается новым символом новой строки или когда включен флаг -b, но текущая строка не нумеруется.
      }
    }
  }
} //

void T(struct flags flag, int *ch) {
  if (flag.T == 1) {
    if (*ch == '\t') {
      printf("^");
      *ch = 'I';
    }
  }
}

void v(struct flags flag, int *ch) {
  if (flag.v == 1) {
    if ((*ch < 32 && *ch != '\n' && *ch != '\t') || *ch == 127)
      printf("^%c", *ch ^ 64);
    else if (*ch >= 128 && *ch < 160)
      printf("M-^%c", *ch ^ 128 ^ 64);
    else if (*ch >= 160) {
      if (*ch == 255) {
        printf("M-^?"); // Обработка символа 255
      } else {
        printf("M-%c", *ch - 128);
      }
    }
  }
}





/*
Команда `continue` в C используется в циклах (например, в `while`, `for`, `do-while`) для перехода к следующей итерации цикла, минуя оставшуюся часть текущей итерации. 

В данном контексте, если условие `s(flag, &prev, &ch, &str)` истинно (т.е., функция `s` возвращает ненулевое значение), то `continue` прерывает текущую итерацию цикла, в котором находится эта строка кода, и переходит к следующей итерации, начиная следующую итерацию цикла снова с проверки условия. 

`continue` - это ключевое слово языка C, и оно не является функцией или частью какой-либо библиотеки. Оно просто является управляющей конструкцией, предназначенной для управления поведением циклов в программе.
*/



/*

`static struct option long_options[] = ...` в вашем коде объявляет массив структур `option`, который используется для задания длинных опций командной строки (long options) в программе. Эти структуры определяются в заголовочном файле `<getopt.h>` и позволяют программе распознавать и обрабатывать как короткие, так и длинные опции командной строки.

Вот более подробное объяснение каждой части:

### struct option

Структура `option` определена в `<getopt.h>` и имеет следующий формат:

```c
struct option {
    const char *name;    // Название длинной опции
    int has_arg;         // Информация о наличии аргумента
    int *flag;           // Указатель на переменную флага
    int val;             // Значение, которое возвращается или присваивается *flag
};
```

### Поля структуры option

1. **name**: Указатель на строку, содержащую название длинной опции. Например, `"number-nonblank"`.

2. **has_arg**: Определяет, принимает ли опция аргумент. Возможные значения:
    - `no_argument` (или 0): опция не принимает аргумент.
    - `required_argument` (или 1): опция требует аргумент.
    - `optional_argument` (или 2): опция может принимать аргумент, но это не обязательно.

3. **flag**: Указатель на переменную, в которую будет записано значение `val` при обнаружении опции. Если это поле `NULL`, `getopt_long` возвращает значение `val`, когда находит эту опцию.

4. **val**: Значение, которое возвращается или присваивается переменной, на которую указывает `flag`. Обычно это символ, представляющий короткую опцию, или специальное значение для длинной опции.

### Пример объявления массива long_options

```c
static struct option long_options[] = {
    {"number-nonblank",  no_argument,       0, 'b'},
    {"number",           no_argument,       0, 'n'},
    {"squeeze-blank",    no_argument,       0, 's'},
    {0, 0, 0, 0}
};
```

### Использование с getopt_long

Массив `long_options` используется в функции `getopt_long`, которая позволяет обрабатывать как короткие, так и длинные опции командной строки. Пример кода:

```c
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char **argv) {
    static struct option long_options[] = {
        {"number-nonblank",  no_argument,       0, 'b'},
        {"number",           no_argument,       0, 'n'},
        {"squeeze-blank",    no_argument,       0, 's'},
        {0, 0, 0, 0}
    };

    int opt;
    int option_index = 0;

    while ((opt = getopt_long(argc, argv, "bns", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'b':
                printf("Option b (number-nonblank) selected.\n");
                break;
            case 'n':
                printf("Option n (number) selected.\n");
                break;
            case 's':
                printf("Option s (squeeze-blank) selected.\n");
                break;
            case '?':
                printf("Unknown option.\n");
                break;
            default:
                printf("Unknown case.\n");
                break;
        }
    }

    return 0;
}
```

В этом примере `getopt_long` обрабатывает как короткие (`-b`, `-n`, `-s`), так и длинные опции (`--number-nonblank`, `--number`, `--squeeze-blank`). Если обнаружена длинная опция, которая совпадает с одной из заданных в `long_options`, возвращается соответствующее значение (например, `'b'`, `'n'`, `'s'`).

*/











/*
./s21_cat -s tests/empty_lines_b_s.txt

   Содержание файла:

   1   .Строка 1
   2   .Строка 2



   3   .Строка 3
   4   .Строка 4  


Ожидаемый результат:

   1   .Строка 1
   2   .Строка 2

   3   .Строка 3
   4   .Строка 4 


- допустим я вписал эту команду. putchar(ch);
    prev = ch; - Объясни пошагово и понятными словами что происходит здесь ? При этой команде
ChatGPT
Конечно, давайте разберем, что происходит на каждом шаге при выполнении команды ./s21_cat -s tests/empty_lines_b_s.txt.

Программа начинает выполнение с чтения файла empty_lines_b_s.txt.
Первая строка содержит текст "Строка 1", за которым следует символ новой строки. Программа считывает каждый символ по очереди.
При считывании символа новой строки после "Строка 1", программа обнаруживает последовательность пустых строк, так как за символом новой строки следует другой символ новой строки. Это происходит внутри функции s(flag, &prev, &ch, &str), которая проверяет, должна ли быть пропущена текущая строка из-за наличия пустых строк.
После проверки s(flag, &prev, &ch, &str), программа продолжает чтение следующих строк и символов до конца файла.
Каждый символ, который не является частью пустых строк, выводится на экран с помощью putchar(ch).
После вывода каждого символа значение текущего символа (ch) присваивается переменной prev, чтобы использовать его при анализе следующего символа.
Таким образом, putchar(ch); просто выводит на экран каждый символ, который не является частью пустых строк, а prev = ch; сохраняет предыдущий символ для последующего использования.

prev = ch - а зачем сохранять предыдущий символ для последующего использования? Для какого последующего использования ? Напимер ? Например для команды с  двумя флагами  ./s21_cat -s -n tests/empty_lines_b_s.txt 
ChatGPT
Правильно, сохранение предыдущего символа prev необходимо для корректной работы программы, особенно когда применяются несколько опций, таких как -s и -n.

В контексте использования флагов -s и -n, сохранение предыдущего символа позволяет программе правильно определять, когда выводить номера строк. Давайте рассмотрим, как это работает на примере команды ./s21_cat -s -n tests/empty_lines_b_s.txt:

Программа начинает считывать содержимое файла empty_lines_b_s.txt.
Когда программа встречает пустую строку, она начинает "сжимать" пустые строки в одну строку. Однако, чтобы выводить номера строк корректно, программа должна знать, что предыдущая строка была пустой, иначе нумерация строк не будет правильной.
Поэтому, если текущий символ - символ новой строки, а предыдущий символ - не символ новой строки, то программа выводит номер строки перед текущей строкой.
Далее, если текущий символ не является символом новой строки, программа просто выводит его на экран без изменений.
Таким образом, сохранение предыдущего символа prev позволяет программе корректно определять, когда выводить номера строк при использовании опции -n вместе с опцией -s.

*/